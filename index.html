<!doctype html>
<html lang="zh-cn">
<head>
<meta charset="utf-8" />
<link rel="stylesheet" href="https://xn--21Erlang-p00o82pmp3o.github.io/theme/main.css" />
<link href="https://xn--21Erlang-p00o82pmp3o.github.io/feeds.rss" type="application/rss+xml" rel="alternate" title="21天学通Erlang RSS Feed" />
<link href="https://xn--21Erlang-p00o82pmp3o.github.io/feeds.atom" type="application/atom+xml" rel="alternate" title="21天学通Erlang Atom Feed" />
<title>21天学通Erlang</title>
</head>
<body>
<header class="header">
<h1><a href="https://xn--21Erlang-p00o82pmp3o.github.io/">21天学通Erlang</a></h1>
<nav class="categories">
</nav>
<nav class="links">
<a href="/book/">获取最新版本</a>
<a href="https://xn--21Erlang-p00o82pmp3o.github.io/feeds.rss">RSS</a>
<a href="https://xn--21Erlang-p00o82pmp3o.github.io/feeds.atom">ATOM</a>
</nav>
<div class="clear"></div>
<nav class="lang">
<span>简体中文</span>
 | <a href="https://xn--21Erlang-p00o82pmp3o.github.io/en/">English</a>
</nav>
</header>
<div class="clear"></div>
<section class="article">
<header>
<abbr class="published" title="2015-10-18T00:00:00+08:00">
2015年10月18日
</abbr>
<h2><a href="https://xn--21Erlang-p00o82pmp3o.github.io/2015/10/how-to-keep-code-snippet-stay-in-sync.html">如何同步代码片段</a></h2>
<div class="article-info">
</div>
</header>
<div class="clear"></div>
<p>因为21天学通Erlang是面向零基础的初学者的，长一点的代码肯定不会是一次写成的，是要分成很多步的。为了方便读者参考，同时也是为了能检验这中间每一步是不是真的没问题，所以每一步都会有一个单独文件，这个文件也要以和最终结果一样的方式检查。假如一个代码片段同时出现在很多个文件里，为了改这个片段，得同时编辑这些文件。这样真是非常非常麻烦，更大的麻烦是没办法检查同一个代码片段在多个文件里是否一致。</p>
<p>于是，我们用<code>snip.py</code>来应付这些问题。给代码片段起个名字，比如下面这个例子中叫my-first-snippet，把代码片段写在<code>% SNIP BEGIN</code>和 <code>% SNIP END</code>之间，这样就可以根据名字来判断是不是同一个片段了。</p>
<pre class="code literal-block">
% SNIP BEGIN my-first-snippet
hello() -&gt;
    world.
% SNIP END
</pre>
<p>运行<code>snip.py build</code>之后，这些注释都会被删掉，就变成下面这样。</p>
<pre class="code literal-block">
hello() -&gt;
    world.
</pre>
<p>Erlang中还有一种特殊的情况，clause之间是用<code>;</code>分开的，但是最后一个clause结尾处用的是<code>.</code>。此时可以用<code>%- SNIP END</code>。这样build后，会把注释前后两行接成一行，不会出现<code>;</code>和<code>.</code>分别单独占一行的情况。比如下面这个例子中，在第一个文件里，只有一个clause。</p>
<pre class="code literal-block">
% SNIP BEGIN my-second-snippet
hello(1) -&gt;
    world
%- SNIP END
.
</pre>
<p>运行<code>snip.py build</code>之后，就变成下面这样。</p>
<pre class="code literal-block">
hello(1) -&gt;
    world.
</pre>
<p>在第二个文件里，有两个clause。</p>
<pre class="code literal-block">
% SNIP BEGIN my-second-snippet
hello(1) -&gt;
    world
%- SNIP END
;
hello(2) -&gt;
    big_world.
</pre>
<p>运行<code>snip.py build</code>之后，就变成下面这样。</p>
<pre class="code literal-block">
hello(1) -&gt;
    world;
hello(2) -&gt;
    big_world.
</pre>
<p>因为恰好LaTeX和Erlang注释用的都是<code>%</code>。可以在LaTeX文档里也可以用同样的记号。为了能在PDF里看到代码片段所在的文件名和行号，需要使用<code>% SNIP REFERENCE</code>。</p>
<pre class="code literal-block">
% SNIP REFERENCE hello.erl my-first-snippet
\begin{SourceCode}
% SNIP BEGIN my-first-snippet
hello(1) -&gt;
    world.
% SNIP END
\end{SourceCode}
</pre>
<p>修改过代码后，运行<code>snip.py status</code>会列出所有不同步的代码片段的名字，接着就可以用<code>snip.py sync</code>来选择某个文件里的片段，把所有文件里的同名代码片段都修改成一样的。</p>

</section>
<section class="article">
<header>
<abbr class="published" title="2015-10-11T00:00:00+08:00">
2015年10月11日
</abbr>
<h2><a href="https://xn--21Erlang-p00o82pmp3o.github.io/2015/10/how-to-verify-log-of-erlang-shell-session.html">核对Erlang Shell会话的记录</a></h2>
<div class="article-info">
</div>
</header>
<div class="clear"></div>
<p>和其他脚本语言的入门教程一样，21天学通Erlang里也会有很多Shell会话的记录。每次生成PDF时，都去人工检查一遍，不仅费时费力，还很容易出错。</p>
<p>为了方便检查这些记录，定义ErlangShellSession这个environment，把LaTeX文档中所有Erlang Shell会话记录输出到单独的文件，这样接下来就只要分别检查这些文件就可以了。</p>
<pre class="code latex literal-block">
<span class="k">\newcounter</span><span class="nb">{</span>erlangshellsession<span class="nb">}</span>[section]
<span class="k">\newoutputstream</span><span class="nb">{</span>erlangshellsession<span class="nb">}</span>
<span class="k">\newenvironment</span><span class="nb">{</span>ErlangShellSession<span class="nb">}{</span>
<span class="k">\stepcounter</span><span class="nb">{</span>erlangshellsession<span class="nb">}</span>
<span class="k">\openoutputfile</span><span class="nb">{</span><span class="k">\currfiledir\theerlangshellsession</span>.session<span class="nb">}{</span>erlangshellsession<span class="nb">}</span>
<span class="k">\writeverbatim</span><span class="nb">{</span>erlangshellsession<span class="nb">}</span>
<span class="nb">}{</span>
<span class="k">\endwriteverbatim</span>
<span class="k">\closeoutputstream</span><span class="nb">{</span>erlangshellsession<span class="nb">}</span>
<span class="k">\begin</span><span class="nb">{</span>SingleSpacing<span class="nb">}</span>
<span class="k">\lstinputlisting</span><span class="na">[title={Erlang Shell}]</span><span class="nb">{</span><span class="k">\currfiledir\theerlangshellsession</span>.session<span class="nb">}</span>
<span class="k">\end</span><span class="nb">{</span>SingleSpacing<span class="nb">}}</span>
</pre>
<p>很糟糕的是，OTP并没有包含类似Python里的doctest的功能。Erlang作者之一，Joe Armstrong不久前也在Erlang Questions邮件列表上问如何实现类似的功能<a class="footnote-reference" href="#interface" id="id1">[1]</a>。</p>
<p>Erlang Shell<a class="reference external" href="http://ferd.ca/repl-a-bit-more-and-less-than-that.html">和一般的REPL在功能上有些出入</a>，而且文档也不全。启动Shell的process，得先把自己设置成<a class="reference external" href="http://www.erlang.org/doc/man/erlang.html#group_leader-0">group leader</a>，这样才能以<a class="reference external" href="http://www.erlang.org/doc/apps/stdlib/io_protocol.html">I/O protocol</a>与Shell通信。收到<code>get_until</code>消息，那么就向Shell发送他想要的内容。收到<code>put_chars</code>消息，就把这些字符和记录去比较。假如所有记录内容都已经比较完了，也没有出现不同，那么就向Shell发送<code>eof</code>消息，等Shell退出。</p>
<table class="docutils footnote" frame="void" id="interface" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td><a class="reference external" href="http://erlang.org/pipermail/erlang-questions/2015-August/085420.html">Programmatic interface to the shell</a></td></tr>
</tbody>
</table>

</section>
<section class="article">
<header>
<abbr class="published" title="2015-10-04T00:00:00+08:00">
2015年10月04日
</abbr>
<h2><a href="https://xn--21Erlang-p00o82pmp3o.github.io/2015/10/why-you-can-teach-yourself-erlang-in-21-days.html">为什么21天能学通Erlang</a></h2>
<div class="article-info">
</div>
</header>
<div class="clear"></div>
<p>21天学通一门程序语言，很多人都认为不现实。比如，Peter Norvig就认为<a class="reference external" href="http://norvig.com/21-days.html">需要十年</a>。还有广为流传的<a class="reference external" href="http://abstrusegoose.com/249">漫画</a>指出，唯一的办法从遥远的未来回到第21天干掉那时的自己。</p>
<p>只是学写个程序，用不着这么残忍。他们都犯了地球中心主义的错误。21天不必是地球上的21天。宇宙这么大，你肯定能找到一个星球。在那个星球上，以你开始学Erlang的那天作为第1天，等你学通Erlang的那天是第21天。这和Perl 6一定会在圣诞节发布<a class="footnote-reference" href="#xmas" id="id3">[1]</a>是同一个道理。</p>
<p>这就是为什么书名并没有骗你。</p>
<table class="docutils footnote" frame="void" id="xmas" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[1]</a></td><td></td></tr>
</tbody>
</table>
<blockquote class="epigraph">
<p>When Perl 6 arrives, every day will be like Christmas!</p>
<p class="attribution">&mdash;<a class="reference external" href="http://pugs.blogs.com/talks/dls06-pugs.pdf">Pugs, an implementation of Perl 6</a></p>
</blockquote>

</section>
<section class="paginator">
<span>1 / 1</span>
</section>
</body>
</html>